<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5, user-scalable=yes">
    <title>WebRTC Video Sender</title>

    <!-- Include stylesheets -->
    <link rel="stylesheet" href="../css/common.css"/>
    <link rel="stylesheet" href="../css/icons.css"/>
    <link rel="stylesheet" href="../css/share-modal.css"/>

    <style>
        :root {
            --bg: #0f1724;
            --panel: #0b1220;
            --muted: #94a3b8;
            --accent: #4f46e5;
            --accent-2: #06b6d4;
            --bubble: #081226;
            --me: #0b2033;
            --text: #e6eef8;
        }

        * {
            box-sizing: border-box;
        }

        html {
            min-height: 100%;
            margin: 0;
            padding: 0;
            border: none;
            background: linear-gradient(180deg, #071225 0%, #071b2b 100%);
            background-attachment: fixed;
        }

        body {
            min-height: 100vh;
            margin: 0;
            padding: 0;
            font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial;
            color: var(--text);
            background: transparent;
        }

        .app-container {
            min-height: 100vh;
            padding: 18px;
        }

        .header {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-2) 100%);
            color: white;
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 20px;
            animation: fadeInDown 0.5s ease-out;
        }

        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .header h1 {
            margin: 0;
            font-size: 28px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
        }

        .header-actions {
            margin-top: 16px;
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .section {
            background: rgba(255, 255, 255, 0.03);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            animation: fadeIn 0.5s ease-out;
        }

        .section h2 {
            margin-top: 0;
            color: var(--text);
            border-bottom: 2px solid rgba(79, 70, 229, 0.3);
            padding-bottom: 10px;
            font-size: 20px;
        }

        .form-row {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 16px;
        }

        label {
            font-size: 13px;
            color: var(--muted);
            font-weight: 600;
        }

        input, select {
            width: 100%;
            padding: 10px 14px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.06);
            background: rgba(255, 255, 255, 0.02);
            color: var(--text);
            font-size: 14px;
        }

        input:focus, select:focus {
            outline: none;
            border-color: rgba(79, 70, 229, 0.6);
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.06);
        }

        /* Distinct styling for the Streaming Mode dropdown */
        #streamingMode {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-2) 100%);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.25);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            font-weight: 600;
        }
        #streamingMode:focus {
            outline: none;
            border-color: rgba(255,255,255,0.6);
            box-shadow: 0 0 0 3px rgba(79,70,229,0.4);
        }
        #streamingMode:hover {
            filter: brightness(1.08);
        }
        #streamingMode option {
            color: #111; /* readable text when dropdown expands (browser dependent) */
        }
        /* High-contrast disabled state */
        #streamingMode:disabled {
            background: linear-gradient(135deg, #555 0%, #444 100%);
            color: #ddd;
            border-color: rgba(255,255,255,0.15);
            filter: grayscale(40%);
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 16px;
        }

        .btn {
            background: linear-gradient(90deg, var(--accent), var(--accent-2));
            color: white;
            border: 1px solid transparent;
            padding: 10px 18px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            outline: none;
        }

        .btn:hover {
            filter: brightness(1.1);
            transform: translateY(-1px);
        }

        .btn:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.2);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(50%);
            transform: none;
        }

        .btn.ghost {
            background: transparent;
            color: var(--muted);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .btn.ghost:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .btn.ghost:focus {
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.1);
        }

        .btn.danger {
            background: linear-gradient(90deg, #dc3545, #c82333);
            border: 1px solid transparent;
        }


        /* Minor field styling for API key */
        .minor-field {
            background: rgba(255, 255, 255, 0.02) !important;
            border: 1px solid rgba(255, 255, 255, 0.05) !important;
            font-size: 12px !important;
            padding: 8px 12px !important;
            color: var(--muted) !important;
            font-family: 'Courier New', monospace;
        }

        .minor-field:focus {
            border-color: rgba(79, 70, 229, 0.3) !important;
            background: rgba(255, 255, 255, 0.03) !important;
        }

        .minor-field-label {
            font-size: 11px !important;
            color: rgba(148, 163, 184, 0.7) !important;
            font-weight: 500 !important;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .video-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .video-card {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .video-card h3 {
            margin: 0;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            font-size: 16px;
            color: var(--text);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .video-wrapper {
            position: relative;
            background: #000;
            aspect-ratio: 16/9;
        }

        .remote-video-box {
            position: relative;
            width: 100%;
            height: 100%;
            background: black;
        }

        .remote-video-box video {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: contain;
            background: black;
        }

        .remote-fs-close {
            display: none;
            position: absolute;
            top: 12px;
            right: 12px;
            z-index: 9999;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }

        #remoteVideoBox:fullscreen .remote-fs-close,
        #remoteVideoBox:-webkit-full-screen .remote-fs-close,
        #remoteVideoBox:-moz-full-screen .remote-fs-close,
        #remoteVideoBox:-ms-fullscreen .remote-fs-close {
            display: block;
        }

        video {
            width: 100%;
            display: block;
        }

        .local-badge {
            position: absolute;
            top: 12px;
            left: 12px;
            background: rgba(79, 70, 229, 0.9);
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            z-index: 10;
            display: none;
        }

        .status {
            padding: 12px;
            border-radius: 8px;
            margin-top: 12px;
            font-size: 13px;
        }

        .status.success {
            background: rgba(16, 185, 129, 0.1);
            color: #10b981;
            border: 1px solid rgba(16, 185, 129, 0.2);
        }

        .status.error {
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.2);
        }

        .status.info {
            background: rgba(59, 130, 246, 0.1);
            color: #3b82f6;
            border: 1px solid rgba(59, 130, 246, 0.2);
        }

        #log {
            background: rgba(0, 0, 0, 0.4);
            color: var(--text);
            padding: 15px;
            border-radius: 10px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
        }

        .log-entry.info {
            color: #4fc3f7;
        }

        .log-entry.success {
            color: #81c784;
        }

        .log-entry.error {
            color: #e57373;
        }

        .log-entry.debug {
            color: #9e9e9e;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            padding: 16px;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.03);
            padding: 16px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(90deg, var(--accent), var(--accent-2));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stat-label {
            font-size: 12px;
            color: var(--muted);
            margin-top: 5px;
        }

        .small {
            font-size: 12px;
            color: var(--muted);
            margin-top: 4px;
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .app-container {
                padding: 12px;
            }

            .header {
                padding: 20px;
            }

            .header h1 {
                font-size: 22px;
            }

            .section {
                padding: 16px;
            }

            .video-grid {
                grid-template-columns: 1fr;
                gap: 16px;
            }

            .controls {
                flex-direction: column;
            }

            .controls .btn {
                width: 100%;
                justify-content: center;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
                padding: 12px;
            }

            .stat-box {
                padding: 12px;
            }

            .stat-value {
                font-size: 20px;
            }

            .header-actions {
                flex-direction: column;
            }

            .header-actions .btn {
                width: 100%;
                justify-content: center;
            }
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 20px;
            }

            .section h2 {
                font-size: 18px;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
<div class="app-container">
<div class="header">
    <h1>
        <svg width="32" height="32" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
        </svg>
        WebRTC Video Sender
    </h1>
    <p>Send live video stream from browser to agent using WebRTC</p>
</div>


<!-- Step 1: Channel Connection -->
<div class="section">
    <h2>üîó Step 1: Connect to Messaging Channel</h2>

    <!-- Connection form (hidden after connect) -->
    <div id="connectionForm">
        <div class="form-row">
            <label for="channelName">Channel Name</label>
            <input type="text" id="channelName" value="demo-webrtc" placeholder="Enter channel name">
        </div>
        <div class="form-row">
            <label for="channelPassword">Channel Password</label>
            <input type="password" id="channelPassword" value="demo123" placeholder="Enter password">
        </div>
        <div class="form-row">
            <label for="agentName">Agent Name (Optional)</label>
            <input type="text" id="agentName" value="" placeholder="Leave empty to auto-generate">
            <div class="small">üí° Leave empty to generate a unique name automatically</div>
        </div>
        <div class="controls">
            <button id="connectBtn" onclick="connectToChannel()" class="btn">
                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
                </svg>
                Connect to Channel
            </button>
        </div>
    </div>

    <!-- Connected state (shown after connect) -->
    <div id="connectedInfo" style="display:none;">
        <div class="form-row">
            <label for="agentNameDisplay">Connected as</label>
            <input type="text" id="agentNameDisplay" readonly style="background: rgba(255, 255, 255, 0.05); cursor: default;">
        </div>
        <div id="relayStatus" style="padding: 12px; margin: 12px 0; border-radius: 8px; background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); display: none;">
            <div style="display: flex; align-items: center; gap: 8px;">
                <svg width="20" height="20" fill="none" stroke="#10b981" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                </svg>
                <span style="color: #10b981; font-weight: 600;">WebRTC Relay Available</span>
            </div>
            <div id="relayAgentsList" style="font-size: 12px; color: var(--muted); margin-top: 4px; margin-left: 28px;"></div>
        </div>
        <div id="relayError" style="padding: 12px; margin: 12px 0; border-radius: 8px; background: rgba(245, 158, 11, 0.1); border: 1px solid rgba(245, 158, 11, 0.3); display: none;">
            <div style="display: flex; align-items: center; gap: 8px;">
                <svg width="20" height="20" fill="none" stroke="#f59e0b" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
                </svg>
                <span style="color: #f59e0b; font-weight: 600;">WebRTC Relay Service Unavailable</span>
            </div>
            <div style="font-size: 13px; color: var(--text); margin-top: 6px; margin-left: 28px; line-height: 1.5;">
                WebRTC peer-to-peer streaming still works, but the SFU relay service is not available. You can stream directly to other agents in the channel.
            </div>
        </div>
        <div class="controls">
            <button id="shareChannelBtn" class="btn" onclick="shareChannel()" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%);">
                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z"/>
                </svg>
                Share Channel
            </button>
            <button id="disconnectBtn" class="btn ghost" onclick="disconnectFromChannel()">
                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                </svg>
                Disconnect
            </button>
        </div>
    </div>

    <div id="connectionStatus"></div>
</div>

<!-- Step 2: Camera Setup -->
<div class="section">
    <h2>üì∑ Step 2: Start Camera or Screen Share</h2>
    <div class="form-row">
        <label for="videoQuality">Video Quality</label>
        <select id="videoQuality">
            <option value="low">Low (640x480, 15fps)</option>
            <option value="medium" selected>Medium (1280x720, 30fps)</option>
            <option value="high">High (1920x1080, 30fps)</option>
        </select>
    </div>
    <!-- Streaming Mode selector -->
    <div class="form-row">
        <label for="streamingMode">Streaming Mode</label>
        <select id="streamingMode">
            <option value="p2p" selected>Peer-to-peer</option>
            <option value="relay">WebRTC Relay</option>
        </select>
    </div>
    <div class="controls">
        <button id="toggleCameraBtn" onclick="toggleCamera()" class="btn" disabled>
            <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
            </svg>
            <span id="cameraButtonText">Start Camera</span>
        </button>
        <button id="toggleScreenBtn" onclick="toggleScreenShare()" class="btn ghost" disabled>
            <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"/>
            </svg>
            <span id="screenButtonText">Share Screen</span>
        </button>
    </div>
</div>

<!-- Stream Status -->
<div class="section">
    <h2>üì° Stream Status</h2>
    <div id="streamStatus"></div>
    <div class="small" style="margin-top: 12px; color: var(--muted);">
        üí° Stream automatically starts when you enable camera or screen sharing and broadcasts to all connected agents.
    </div>
</div>

<!-- Video Preview -->
<div class="section">
    <h2>üì∫ Video Preview</h2>
    <div class="video-grid">
        <div class="video-card">
            <h3>üì∑ Local Camera</h3>
            <div class="video-wrapper">
                <div id="localBadge" class="local-badge" aria-hidden="true">Camera</div>
                <video id="localVideo" autoplay muted playsinline></video>
            </div>
            <div class="controls" style="padding: 8px; margin-top: 8px;">
                <button id="muteLocalVideoBtn" class="btn ghost" onclick="toggleLocalVideoMute()" disabled title="Toggle video">
                    <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
                    </svg>
                    <span id="localVideoMuteText">Disable Video</span>
                </button>
                <button id="muteLocalAudioBtn" class="btn ghost" onclick="toggleLocalAudioMute()" disabled title="Toggle audio">
                    <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"/>
                    </svg>
                    <span id="localAudioMuteText">Mute Audio</span>
                </button>
            </div>
        </div>
        <div class="video-card">
            <h3>üì° Streaming Status</h3>
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-value" id="statState">Idle</div>
                    <div class="stat-label">Connection State</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="statIce">0</div>
                    <div class="stat-label">ICE Candidates</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="statBitrate">0 kbps</div>
                    <div class="stat-label">Bitrate</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="statFrames">0</div>
                    <div class="stat-label">Frames Sent</div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Remote Preview -->
<div class="section">
    <h2>üì° Remote Streams (<span id="remoteStreamCount">0</span>)</h2>
    <div id="remoteStreamsContainer" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(400px, 1fr)); gap: 16px;">
        <!-- Remote stream cards will be dynamically added here -->
        <div id="noRemoteStreams" class="video-card" style="grid-column: 1 / -1; text-align: center; padding: 40px; color: var(--muted);">
            <svg width="64" height="64" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="margin: 0 auto 16px;">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
            </svg>
            <p>No remote streams yet. Waiting for other agents to share video...</p>
        </div>
    </div>
</div>

<!-- Log Output -->
<div class="section">
    <h2>üìã Activity Log</h2>
    <div class="controls">
        <button class="btn ghost" onclick="clearLog()">
            <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
            </svg>
            Clear Log
        </button>
    </div>
    <div id="log"></div>
</div>

</div><!-- end app-container -->

<!-- Include required scripts -->
<script src="../js/lib/qrcode.min.js"></script>
<script src="../js/config-loader.js"></script>
<script src="../generated-web-agent-js/js/web-agent.libs.js"></script>
<script src="../generated-web-agent-js/js/web-agent.js"></script>
<script src="../generated-web-agent-js/js/web-agent.webrtc.js"></script>
<script src="../js/common-utils.js"></script>
<script src="../js/share-modal.js"></script>

<script>
    // Global variables
    let channel = null;
    let webrtcHelper = null;
    let localStream = null;
    let currentStreamId = null;
    let iceCount = 0;
    let statsInterval = null;
    let lastReceivedStreamId = null;
    // Saved camera stream when temporarily switching to screen share
    let savedCameraStream = null;
    // Map to track multiple remote streams: streamId -> {stream, sourceAgent, videoElement, container}
    const remoteStreams = new Map();

    /**
     * Replace RTCRtpSender tracks on an active peer connection for a given stream session.
     * Attempts to match senders by track kind (video/audio) and replace with tracks from newStream.
     */
    async function replaceSenders(newStream, streamId) {
        if (!webrtcHelper || !webrtcHelper.peerConnections) {
            console.warn('replaceSenders: no webrtcHelper.peerConnections available');
            return;
        }
        const pc = webrtcHelper.peerConnections.get(streamId);
        if (!pc) {
            console.warn('replaceSenders: no PeerConnection for streamId', streamId);
            return;
        }

        try {
            const newTracks = (newStream && newStream.getTracks) ? newStream.getTracks() : [];
            const senders = pc.getSenders ? pc.getSenders() : [];

            // Replace existing senders' tracks by kind
            for (const track of newTracks) {
                const kind = track.kind;
                let sender = senders.find(s => s.track && s.track.kind === kind);
                if (!sender) {
                    // No existing sender for this kind: add a new track to the connection
                    try {
                        pc.addTrack(track, newStream);
                        console.log('[replaceSenders] added new ' + kind + ' track to pc');
                    } catch (e) {
                        console.warn('[replaceSenders] failed to addTrack for kind', kind, e);
                    }
                } else {
                    try {
                        await sender.replaceTrack(track);
                        console.log('[replaceSenders] replaced ' + kind + ' sender.track');
                    } catch (e) {
                        console.warn('[replaceSenders] replaceTrack failed for kind', kind, e);
                        // fallback: attempt to addTrack if replaceTrack not supported
                        try { pc.addTrack(track, newStream); } catch (e2) { /* ignore */ }
                    }
                }
            }

            // If there is no video track in newStream, ensure we mute/remove the video sender
            const hasVideo = newTracks.some(t => t.kind === 'video');
            if (!hasVideo) {
                for (const s of senders) {
                    if (s.track && s.track.kind === 'video') {
                        try { await s.replaceTrack(null); } catch (e) { /* ignore */ }
                    }
                }
            }

            // Update helper localStreams map if present
            try { webrtcHelper.localStreams.set(streamId, newStream); } catch (e) { /* ignore */ }
        } catch (err) {
            console.error('replaceSenders error', err);
        }
    }

    // Handler for incoming remote streams (declared up-front so it's available when registering callbacks)
    function onRemoteStream(streamId, stream, sourceAgent) {
        console.log('[DEBUG] onRemoteStream called:', streamId, stream, 'from:', sourceAgent);

        // Use passed sourceAgent or fallback to lookup if not provided
        if (!sourceAgent || sourceAgent === 'Unknown') {
            const session = webrtcHelper?.streamSessions?.get(streamId);
            sourceAgent = session?.remoteAgent || 'Unknown';
        }

        console.log('[DEBUG] Final sourceAgent:', sourceAgent);

        // Check if card already exists for this streamId
        if (remoteStreams.has(streamId)) {
            console.log('[DEBUG] Stream card already exists, updating existing card');
            // Card already exists, just update the video element's stream
            const streamData = remoteStreams.get(streamId);
            if (streamData.videoElement) {
                streamData.videoElement.srcObject = stream;
                // Update the stream reference
                streamData.stream = stream;
                remoteStreams.set(streamId, streamData);
            }
            log('üîÑ Updated existing stream from ' + sourceAgent + ': ' + streamId, 'info');
            return; // Don't create a new card
        }

        // Create UI card for this remote stream (first time)
        console.log('[DEBUG] Creating new stream card');
        createRemoteStreamCard(streamId, stream, sourceAgent);

        // Update stream count
        updateRemoteStreamCount();

        log('‚úÖ Remote stream received from ' + sourceAgent + ': ' + streamId, 'success');
    }

    // Create a card for a remote stream
    function createRemoteStreamCard(streamId, stream, sourceAgent) {
        const container = document.getElementById('remoteStreamsContainer');
        const noStreamsMsg = document.getElementById('noRemoteStreams');

        // Hide "no streams" message
        if (noStreamsMsg) noStreamsMsg.style.display = 'none';

        // Create video card
        const card = document.createElement('div');
        card.className = 'video-card';
        card.id = 'remote-card-' + streamId;
        card.style.position = 'relative';

        card.innerHTML = `
            <h3>üì∫ ${sourceAgent}</h3>
            <div class="video-wrapper">
                <div class="remote-video-box" style="position: relative;">
                    <video id="remote-video-${streamId}" autoplay playsinline muted style="width: 100%; height: 100%; object-fit: cover;"></video>
                </div>
            </div>
            <div class="controls" style="padding: 8px; display: flex; gap: 8px; flex-wrap: wrap;">
                <button class="btn" onclick="toggleRemoteStreamAudio('${streamId}')" title="Unmute audio">
                    <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z"/>
                    </svg>
                    <span id="mute-text-${streamId}">Unmute</span>
                </button>
                <button class="btn ghost" onclick="hideRemoteStream('${streamId}')" title="Hide stream">
                    <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"/>
                    </svg>
                    <span id="hide-text-${streamId}">Hide</span>
                </button>
                <button class="btn ghost" onclick="toggleRemoteStreamFullscreen('${streamId}')" title="Fullscreen">
                    <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"/>
                    </svg>
                    Fullscreen
                </button>
            </div>
            <div style="padding: 8px; font-size: 12px; color: var(--muted);">
                Stream ID: ${streamId.substring(0, 20)}...
            </div>
        `;

        container.appendChild(card);

        // Get video element and set stream
        const videoEl = document.getElementById('remote-video-' + streamId);
        if (videoEl) {
            videoEl.srcObject = stream;

            // Explicitly play the video
            videoEl.play().catch(err => {
                console.error('[DEBUG] Remote video play() failed:', err);
                videoEl.muted = true;
                videoEl.play().catch(err2 => {
                    console.error('[DEBUG] Remote video play() still failed:', err2);
                });
            });
        }

        // Store in map
        remoteStreams.set(streamId, {
            stream: stream,
            sourceAgent: sourceAgent,
            videoElement: videoEl,
            container: card,
            hidden: false,
            muted: true
        });

        lastReceivedStreamId = streamId;
    }

    // Toggle audio for a specific remote stream
    function toggleRemoteStreamAudio(streamId) {
        const streamData = remoteStreams.get(streamId);
        if (!streamData || !streamData.videoElement) return;

        streamData.videoElement.muted = !streamData.videoElement.muted;
        streamData.muted = streamData.videoElement.muted;

        const muteText = document.getElementById('mute-text-' + streamId);
        const muteBtn = muteText?.parentElement;

        if (streamData.videoElement.muted) {
            if (muteText) muteText.textContent = 'Unmute';
            if (muteBtn) muteBtn.classList.remove('danger');
            log('üîá Muted remote stream from ' + streamData.sourceAgent, 'info');
        } else {
            if (muteText) muteText.textContent = 'Mute';
            if (muteBtn) muteBtn.classList.add('danger');
            log('üîä Unmuted remote stream from ' + streamData.sourceAgent, 'success');
        }
    }

    // Hide/show a remote stream (keeps connection but hides video)
    function hideRemoteStream(streamId) {
        const streamData = remoteStreams.get(streamId);
        if (!streamData) return;

        streamData.hidden = !streamData.hidden;

        const hideText = document.getElementById('hide-text-' + streamId);
        const hideBtn = hideText?.parentElement;

        if (streamData.hidden) {
            streamData.container.style.opacity = '0.5';
            streamData.videoElement.style.visibility = 'hidden';
            if (hideText) hideText.textContent = 'Show';
            if (hideBtn) hideBtn.classList.add('primary');
            log('üëÅÔ∏è Hidden stream from ' + streamData.sourceAgent, 'info');
        } else {
            streamData.container.style.opacity = '1';
            streamData.videoElement.style.visibility = 'visible';
            if (hideText) hideText.textContent = 'Hide';
            if (hideBtn) hideBtn.classList.remove('primary');
            log('üëÅÔ∏è Showing stream from ' + streamData.sourceAgent, 'info');
        }
    }

    // Toggle fullscreen for a specific remote stream
    function toggleRemoteStreamFullscreen(streamId) {
        const streamData = remoteStreams.get(streamId);
        if (!streamData || !streamData.videoElement) return;

        const videoBox = streamData.videoElement.parentElement;

        if (isElementFullscreen(videoBox)) {
            exitFullscreenIfAny();
        } else {
            enterFullscreen(videoBox);
        }
    }

    // Remove a remote stream
    function removeRemoteStream(streamId) {
        const streamData = remoteStreams.get(streamId);
        if (!streamData) return;

        // Close WebRTC connection
        try {
            if (webrtcHelper) webrtcHelper.closeStream(streamId);
        } catch (e) {
            console.warn('Error closing stream:', e);
        }

        // Stop tracks and cleanup video
        if (streamData.videoElement && streamData.videoElement.srcObject) {
            try {
                streamData.videoElement.srcObject.getTracks().forEach(t => t.stop());
            } catch (e) { /* ignore */ }
            streamData.videoElement.srcObject = null;
        }

        // Remove from DOM
        if (streamData.container && streamData.container.parentElement) {
            streamData.container.remove();
        }

        // Remove from map
        remoteStreams.delete(streamId);

        // Update count and show "no streams" message if needed
        updateRemoteStreamCount();

        log('‚ùå Closed stream from ' + streamData.sourceAgent, 'info');
    }

    // Update remote stream count display
    function updateRemoteStreamCount() {
        const count = remoteStreams.size;
        const countEl = document.getElementById('remoteStreamCount');
        if (countEl) countEl.textContent = count;

        const noStreamsMsg = document.getElementById('noRemoteStreams');
        if (noStreamsMsg) {
            noStreamsMsg.style.display = count === 0 ? 'block' : 'none';
        }
    }

    // Legacy function for compatibility (removes last received stream)
    function stopReceiving() {
        if (lastReceivedStreamId) {
            removeRemoteStream(lastReceivedStreamId);
        }
    }

    // Fullscreen helpers for remote video
    function isElementFullscreen(el) {
        return (document.fullscreenElement === el) || (document.webkitFullscreenElement === el) || (document.mozFullScreenElement === el) || (document.msFullscreenElement === el);
    }

    async function enterFullscreen(element) {
        if (!element) return;
        try {
            if (element.requestFullscreen) await element.requestFullscreen();
            else if (element.webkitRequestFullscreen) await element.webkitRequestFullscreen();
            else if (element.mozRequestFullScreen) await element.mozRequestFullScreen();
            else if (element.msRequestFullscreen) await element.msRequestFullscreen();
        } catch (e) {
            console.warn('Fullscreen request failed', e);
        }
    }

    async function exitFullscreenIfAny() {
        try {
            if (document.exitFullscreen) await document.exitFullscreen();
            else if (document.webkitExitFullscreen) await document.webkitExitFullscreen();
            else if (document.mozCancelFullScreen) await document.mozCancelFullScreen();
            else if (document.msExitFullscreen) await document.msExitFullscreen();
        } catch (e) {
            /* ignore */
        }
    }

    // Legacy function for old single stream code
    function toggleRemoteFullscreen() {
        if (lastReceivedStreamId) {
            toggleRemoteStreamFullscreen(lastReceivedStreamId);
        }
    }

    function enterFullscreenForRemote() {
        if (lastReceivedStreamId) {
            toggleRemoteStreamFullscreen(lastReceivedStreamId);
        }
    }

    // Update fullscreen button label when fullscreen state changes
    function updateFullscreenButton() {
        const btn = document.getElementById('remoteFullscreenBtn');
        const container = document.getElementById('remoteVideoBox') || document.getElementById('remoteVideo');
         if (!btn) return;
         try {
            if (isElementFullscreen(container)) btn.textContent = 'Exit Fullscreen';
            else btn.textContent = 'Fullscreen';
         } catch (e) { /* ignore */ }
     }

     document.addEventListener('fullscreenchange', updateFullscreenButton);
     document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
     document.addEventListener('mozfullscreenchange', updateFullscreenButton);
     document.addEventListener('MSFullscreenChange', updateFullscreenButton);

    // Logging functions
    function log(message, type = 'info') {
        const logDiv = document.getElementById('log');
        const entry = document.createElement('div');
        entry.className = `log-entry ${type}`;
        const timestamp = new Date().toLocaleTimeString();
        entry.textContent = `[${timestamp}] ${message}`;
        logDiv.appendChild(entry);
        logDiv.scrollTop = logDiv.scrollHeight;
        console.log(`[${type.toUpperCase()}] ${message}`);
    }

    function clearLog() {
        document.getElementById('log').innerHTML = '';
    }

    function showStatus(elementId, message, type) {
        const statusDiv = document.getElementById(elementId);
        statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
    }

    // Step 1: Connect to Channel
    async function connectToChannel() {
        console.log('[DEBUG] connectToChannel() called');
        const channelName = document.getElementById('channelName').value.trim();
        const password = document.getElementById('channelPassword').value.trim();

        // TEMPORARY KEY SYSTEM: Request fresh API key on each connect using config-loader
        console.log('Requesting fresh temporary API key...');
        let apiKey;
        try {
            // Use multi-use key with 300s TTL for connection (allows multiple operations)
            const config = await window.fetchAppConfig(300, false);
            if (!config || !config.apiKey) {
                throw new Error('No API key in response');
            }
            apiKey = config.apiKey;
            console.log('Fresh temporary API key obtained for connection (multi-use, 300s TTL)');
        } catch (err) {
            console.error('Failed to get temporary API key:', err);
            showStatus('connectionStatus', 'Error: Failed to get API key from server - ' + err.message, 'error');
            return;
        }

        let agentName = document.getElementById('agentName').value.trim();

        console.log('[DEBUG] Form values in connectToChannel:', {
            channelName: channelName,
            password: password,
            apiKey: apiKey,
            agentName: agentName
        });

        if (!channelName || !password || !apiKey) {
            console.log('[DEBUG] Validation failed - missing required fields');
            showStatus('connectionStatus', '‚ùå Please fill in required fields', 'error');
            return;
        }

        console.log('[DEBUG] Validation passed, proceeding with connection...');

        // Auto-generate agent name if empty
        if (!agentName) {
            agentName = 'webrtc-' + generateRandomAgentName();
            log('Generated agent name: ' + agentName, 'info');
        }

        log('Connecting to channel: ' + channelName + ' as ' + agentName, 'info');

        try {
            // Create c hannel instance
            channel = new AgentConnection({enableWebrtcRelay: true});

            // Initialize WebRTC helper BEFORE connecting to ensure signaling handler is ready
            webrtcHelper = new WebRtcHelper(channel);
            setupWebRtcCallbacks(webrtcHelper);

            // If camera already started, register it as default local stream
            if (localStream && typeof webrtcHelper.setLocalMediaStream === 'function') {
                webrtcHelper.setLocalMediaStream(localStream);
            }

            // Connect to channel using Promise
            await new Promise((resolve, reject) => {
                // Set up event listener for connection
                channel.addEventListener('connect', function (event) {
                    if (event.response && event.response.status === 'success') {
                        resolve();
                    } else {
                        // Use statusMessage from response
                        const errorMsg = event.response?.statusMessage || 'Connection failed';
                        reject(new Error(errorMsg));
                    }
                });

                // Connect with proper configuration
                channel.connect({
                    channelName: channelName,
                    channelPassword: password,
                    agentName: agentName,
                    api: 'https://hmdevonline.com/messaging-platform/api/v1/messaging-service',
                    apiKey: apiKey,
                    apiKeyScope: 'public',
                    useInitialReceiveConfig: true,
                    autoReceive: true
                });
            });

            log('‚úÖ Connected to channel successfully', 'success');
            showStatus('connectionStatus', '‚úÖ Connected to channel: ' + channelName, 'success');

            // Check for webrtc-relay system agents
            log('üîç Checking for webrtc-relay system agents...', 'info');
            try {
                await new Promise((resolve, reject) => {
                    channel.getSystemAgents(function(response) {
                        if (response && response.status === 'success' && response.data) {
                            const systemAgents = response.data;
                            // Check agent.role field (preferred) or metadata.role or legacy agentContext.role
                            const relayAgents = systemAgents.filter(agent =>
                                agent.role === 'webrtc-relay' ||
                                agent.metadata?.role === 'webrtc-relay' ||
                                agent.agentContext?.role === 'webrtc-relay'
                            );

                            if (relayAgents.length === 0) {
                                reject(new Error('No webrtc-relay agents found. Live streaming is not available.'));
                            } else {
                                const relayNames = relayAgents.map(a => a.agentName || a.name);
                                log('‚úÖ Found ' + relayAgents.length + ' webrtc-relay agent(s): ' + relayNames.join(', '), 'success');
                                // Store relay agent names globally for use in streaming
                                window.webrtcRelayAgents = relayNames;

                                // Show relay status in UI
                                document.getElementById('relayStatus').style.display = 'block';
                                document.getElementById('relayError').style.display = 'none';
                                document.getElementById('relayAgentsList').textContent =
                                    'Relay agents: ' + relayNames.join(', ');

                                resolve();
                            }
                        } else {
                            reject(new Error('Failed to retrieve system agents'));
                        }
                    });
                });
            } catch (relayError) {
                log('‚ö†Ô∏è WebRTC Relay Service: ' + relayError.message, 'info');

                // Show warning in UI (not an error - peer-to-peer still works)
                document.getElementById('relayStatus').style.display = 'none';
                document.getElementById('relayError').style.display = 'block';

                // Keep buttons enabled - peer-to-peer streaming still works
                // Camera and screen share buttons remain functional for P2P
            }

            // Hide connection form and show connected info
            document.getElementById('connectionForm').style.display = 'none';
            document.getElementById('connectedInfo').style.display = 'block';
            document.getElementById('agentNameDisplay').value = agentName;

            // Always enable camera and screen share buttons (peer-to-peer works without relay)
            document.getElementById('toggleCameraBtn').disabled = false;
            document.getElementById('toggleScreenBtn').disabled = false;

            // Show floating share button when connected
            try {
                const shareBtn = document.getElementById('shareChannelBtn');
                if (shareBtn) shareBtn.style.display = 'flex';
            } catch (e) { /* ignore */ }


        } catch (error) {
            console.error('Connection error:', error);
            const errorMsg = error.message || 'Unknown error';
            log('‚ùå Connection failed: ' + errorMsg, 'error');
            showStatus('connectionStatus', '‚ùå Connection failed: ' + errorMsg, 'error');
        }
    }

    // Setup WebRTC callbacks
    function setupWebRtcCallbacks(webrtcHelper) {

        webrtcHelper.on('offer', (streamId, sdp) => {
            log('üì§ SDP Offer created (' + sdp.length + ' bytes)', 'success');
        });

        webrtcHelper.on('answer', (streamId, sdp) => {
            const sdpLen = sdp ? sdp.length : 'n/a';
            log('üì• SDP Answer received from agent (stream=' + streamId + ', len=' + sdpLen + ')', 'success');
        });

        webrtcHelper.on('ice-candidate', (streamId, candidate) => {
            iceCount++;
            document.getElementById('statIce').textContent = iceCount;
            const candidateText = candidate && candidate.candidate ? candidate.candidate : JSON.stringify(candidate);
            log('üßä ICE candidate generated (stream=' + streamId + ') ' + candidateText, 'debug');
        });

        webrtcHelper.on('stream-ready', (streamId, remoteAgent) => {
            log('‚úÖ WebRTC connection established with ' + remoteAgent, 'success');
            document.getElementById('statState').textContent = 'Connected';
            startStatsMonitoring(streamId);
        });

        webrtcHelper.on('error', (streamId, error) => {
            log('‚ùå WebRTC error: ' + error, 'error');
            showStatus('streamStatus', '‚ùå Error: ' + error, 'error');
        });

        // Handle connection state changes - auto-remove closed streams
        webrtcHelper.on('connection-state', (streamId, state) => {
            log('üîó Connection state for ' + streamId + ': ' + state, 'debug');

            // When connection is closed/failed/disconnected, remove the remote stream
            if (state === 'closed' || state === 'failed' || state === 'disconnected') {
                log('‚ö†Ô∏è Connection ' + state + ', removing remote stream: ' + streamId, 'info');

                // Remove from our remote streams map
                if (remoteStreams.has(streamId)) {
                    // Use a small delay to ensure any reconnection attempts complete first
                    setTimeout(() => {
                        if (remoteStreams.has(streamId)) {
                            const streamData = remoteStreams.get(streamId);
                            log('üóëÔ∏è Auto-removing closed stream from ' + (streamData?.sourceAgent || 'Unknown'), 'info');
                            removeRemoteStream(streamId);
                        }
                    }, 2000); // 2 second delay before cleanup
                }
            }
        });

        // Register remote stream handler
        webrtcHelper.on('remote-stream', (streamId, stream, sourceAgent) => {
            try {
                if (typeof onRemoteStream === 'function') {
                    onRemoteStream(streamId, stream, sourceAgent);
                } else {
                    console.warn('remote-stream received but onRemoteStream handler is not defined');
                }
            } catch (e) {
                console.error('Error in remote-stream wrapper:', e);
            }
        });

        // Listen for agent connections
        if (channel) {
            channel.addEventListener('agent-connect', async function(event) {

                const newAgentName = event.agentName;
                // Check metadata first (new), then agentContext (legacy)
                const agentData = event.metadata || event.agentContext;
                const isRelayAgent = agentData && agentData.role === 'webrtc-relay';
                log('üë§ New agent connected: ' + newAgentName + (isRelayAgent ? ' (relay)' : ''), 'success');

                // Add to relay agents list
                if (isRelayAgent)
                {
                    window.webrtcRelayAgents = window.webrtcRelayAgents || [];
                    if (!window.webrtcRelayAgents.includes(newAgentName)) {
                        window.webrtcRelayAgents.push(newAgentName);
                    }
                }

                const mode = getStreamingMode();
                console.log('newAgentName=', newAgentName, 'isRelayAgent=', isRelayAgent, 'mode=', mode,
                    'currentStreamId=', currentStreamId);

                if (mode === 'p2p' && !isRelayAgent) {
                    log('üì° P2P mode: sending stream to agent', newAgentName);
                    startVideoStream([newAgentName]);

                } else if (mode === 'relay' && isRelayAgent) {
                    log('üì° Relay mode: sending stream to relay agent', newAgentName);
                    startVideoStream([newAgentName]);
                }
            });

            channel.addEventListener('agent-disconnect', function(event) {
                const disconnectedAgent = event.agentName;
                // Check metadata first (new), then agentContext (legacy)
                const agentData = event.metadata || event.agentContext;
                const isRelayAgent = agentData && agentData.role === 'webrtc-relay';
                log('üëã Agent disconnected: ' + disconnectedAgent + (isRelayAgent ? ' (relay)' : ''), 'info');

                // If a relay agent disconnected, remove from list
                if (isRelayAgent) {
                    if (window.webrtcRelayAgents) {
                        const index = window.webrtcRelayAgents.indexOf(disconnectedAgent);
                        if (index > -1) {
                            window.webrtcRelayAgents.splice(index, 1);
                            log('‚ö†Ô∏è WebRTC relay agent disconnected', 'info');

                            // If no more relay agents, show warning but keep streaming enabled
                            if (window.webrtcRelayAgents.length === 0) {
                                log('‚ö†Ô∏è WebRTC relay disconnected - switching to peer-to-peer mode', 'info');

                                // Update UI to show warning
                                document.getElementById('relayStatus').style.display = 'none';
                                document.getElementById('relayError').style.display = 'block';

                                // Keep buttons enabled - peer-to-peer still works
                                showStatus('streamStatus', '‚ö†Ô∏è Relay disconnected - using peer-to-peer mode', 'info');
                            }
                        }
                    }
                }
            });
        }
    }

    // Step 2: Start Camera
    async function startCamera() {
        const quality = document.getElementById('videoQuality').value;

        let constraints = {
            video: {},
            audio: true
        };

        // Set quality constraints
        switch (quality) {
            case 'low':
                constraints.video = {width: 640, height: 480, frameRate: 15};
                break;
            case 'high':
                constraints.video = {width: 1920, height: 1080, frameRate: 30};
                break;
            default: // medium
                constraints.video = {width: 1280, height: 720, frameRate: 30};
        }

        log('Starting camera with ' + quality + ' quality...', 'info');

        try {
            localStream = await navigator.mediaDevices.getUserMedia(constraints);

            // Display in video element
            document.getElementById('localVideo').srcObject = localStream;

            log('‚úÖ Camera started successfully', 'success');
            log('Resolution: ' + localStream.getVideoTracks()[0].getSettings().width + 'x' +
                localStream.getVideoTracks()[0].getSettings().height, 'info');

            // Set local stream in helper
            if (webrtcHelper && typeof webrtcHelper.setLocalMediaStream === 'function') {
                webrtcHelper.setLocalMediaStream(localStream);
            }

            // Update UI
            document.getElementById('muteLocalVideoBtn').disabled = false;
            document.getElementById('muteLocalAudioBtn').disabled = false;
            document.getElementById('toggleScreenBtn').style.display = 'none'; // Hide screen share while camera active
            try { const b = document.getElementById('localBadge'); if (b) { b.textContent = 'Camera'; b.style.display = 'inline-block'; } } catch (e) {}

            // Automatically start streaming to all connected agents
            await startVideoStream();

        } catch (error) {
            log('‚ùå Camera error: ' + error.message, 'error');
            alert('Failed to access camera: ' + error.message);
        }
    }

    // Stop Camera
    function stopCamera() {
        if (localStream) {
            log('Stopping camera...', 'info');

            // Close active WebRTC stream session if exists
            if (currentStreamId && webrtcHelper) {
                try {
                    log('Closing WebRTC stream: ' + currentStreamId, 'debug');
                    // Use WebRTC helper's closeStream to properly notify remote peers
                    webrtcHelper.closeStream(currentStreamId);
                    currentStreamId = null;
                } catch (e) {
                    console.warn('Error closing WebRTC stream:', e);
                }
            }

            // Stop all tracks
            localStream.getTracks().forEach(track => track.stop());
            document.getElementById('localVideo').srcObject = null;
            localStream = null;

            // Unregister from helper default stream if present
            if (webrtcHelper && typeof webrtcHelper.setLocalMediaStream === 'function') {
                try { webrtcHelper.setLocalMediaStream(null); } catch (e) { /* ignore */ }
            }

            log('Camera stopped', 'info');
            document.getElementById('muteLocalVideoBtn').disabled = true;
            document.getElementById('muteLocalAudioBtn').disabled = true;
            document.getElementById('toggleScreenBtn').style.display = 'inline-flex'; // Show screen share button
            // hide badge
            try { const b = document.getElementById('localBadge'); if (b) { b.style.display = 'none'; } } catch (e) {}
        }
    }

    // Toggle Camera (combines start/stop)
    async function toggleCamera() {
        if (localStream && !isScreenSharing) {
            // Camera is active, stop it
            stopCamera();
            document.getElementById('cameraButtonText').textContent = 'Start Camera';
            document.getElementById('toggleCameraBtn').classList.remove('danger');
        } else if (!localStream && !isScreenSharing) {
            // Camera is not active, start it
            await startCamera();
            document.getElementById('cameraButtonText').textContent = 'Stop Camera';
            document.getElementById('toggleCameraBtn').classList.add('danger');
        }
    }

    // Toggle Screen Share (combines start/stop)
    async function toggleScreenShare() {
        if (isScreenSharing) {
            // Screen share is active, stop it
            stopScreenShare();
            document.getElementById('screenButtonText').textContent = 'Share Screen';
            document.getElementById('toggleScreenBtn').classList.remove('danger');
        } else {
            // Screen share is not active, start it
            await startScreenShare();
            document.getElementById('screenButtonText').textContent = 'Stop Share';
            document.getElementById('toggleScreenBtn').classList.add('danger');
        }
    }

    // Screen / Tab sharing support
    let isScreenSharing = false;

    async function startScreenShare() {
        try {
            if (isScreenSharing) return;

            log('Requesting screen/tab share...', 'info');

            const displayStream = await navigator.mediaDevices.getDisplayMedia({ video: { cursor: 'always' }, audio: true });

            // Stop camera if active and save it
            if (localStream) {
                savedCameraStream = localStream;
                stopCamera();
            }

            // Set screen stream
            localStream = displayStream;
            isScreenSharing = true;
            document.getElementById('localVideo').srcObject = localStream;

            // Set local stream in helper
            if (webrtcHelper && typeof webrtcHelper.setLocalMediaStream === 'function') {
                webrtcHelper.setLocalMediaStream(localStream);
            }

            // Update UI
            document.getElementById('toggleCameraBtn').style.display = 'none'; // Hide camera button while screen sharing
            document.getElementById('muteLocalVideoBtn').disabled = false;
            document.getElementById('muteLocalAudioBtn').disabled = false;
            try { const b = document.getElementById('localBadge'); if (b) { b.textContent = 'Screen'; b.style.display = 'inline-block'; } } catch (e) {}

            log('‚úÖ Screen share started', 'success');

            // Automatically start streaming to all connected agents
            await startVideoStream();

            // Detect when user stops screen share via browser UI
            displayStream.getTracks().forEach(track => {
                track.onended = () => {
                    setTimeout(() => {
                        if (isScreenSharing) {
                            stopScreenShare();
                            // Reset screen share button state
                            document.getElementById('screenButtonText').textContent = 'Share Screen';
                            document.getElementById('toggleScreenBtn').classList.remove('danger');
                        }
                    }, 50);
                };
            });

        } catch (err) {
            console.error('Screen share failed', err);
            log('‚ùå Screen share failed: ' + (err && err.message ? err.message : err), 'error');
            alert('Failed to start screen share: ' + (err && err.message ? err.message : err));
        }
    }

    async function stopScreenShare() {
        try {
            // Only return if neither screen sharing nor any local stream is active
            if (!isScreenSharing && !localStream) return;

            log('Stopping screen share...', 'info');

            // Close active WebRTC stream session if exists
            if (currentStreamId && webrtcHelper) {
                try {
                    log('Closing WebRTC stream: ' + currentStreamId, 'debug');
                    // Use WebRTC helper's closeStream to properly notify remote peers
                    webrtcHelper.closeStream(currentStreamId);
                    currentStreamId = null;
                } catch (e) {
                    console.warn('Error closing WebRTC stream:', e);
                }
            }

            // Stop all local stream tracks
            if (localStream) {
                try {
                    localStream.getTracks().forEach(t => {
                        t.stop();
                        log('Stopped track: ' + t.kind, 'debug');
                    });
                } catch (e) {
                    console.warn('Error stopping tracks:', e);
                }

                // Clear video element
                const localEl = document.getElementById('localVideo');
                if (localEl && localEl.srcObject) {
                    try {
                        localEl.srcObject.getTracks().forEach(t => t.stop());
                    } catch (e) { /* ignore */ }
                    localEl.srcObject = null;
                }
            }

            // Unregister from helper
            if (webrtcHelper && typeof webrtcHelper.setLocalMediaStream === 'function') {
                try { webrtcHelper.setLocalMediaStream(null); } catch (e) { /* ignore */ }
            }

            // If we have a saved camera stream restore it and (if active session) replace senders
            const prevCamera = savedCameraStream;
            isScreenSharing = false;
            localStream = null;

            if (prevCamera) {
                // restore preview
                try { localStream = prevCamera; document.getElementById('localVideo').srcObject = localStream; } catch (e) { localStream = null; }
                if (webrtcHelper && typeof webrtcHelper.setLocalMediaStream === 'function') {
                    try { webrtcHelper.setLocalMediaStream(localStream); } catch (e) { /* ignore */ }
                }
                // If active session, update senders to camera tracks
                if (currentStreamId && localStream) {
                    try { await replaceSenders(localStream, currentStreamId); } catch (e) { console.warn('replaceSenders restoring camera failed', e); }
                }
                // clear saved camera if we restored
                savedCameraStream = null;
                // show badge
                try { const b = document.getElementById('localBadge'); if (b) { b.textContent = 'Camera'; b.style.display = 'inline-block'; } } catch (e) {}
                // Update camera button to show "Stop Camera"
                document.getElementById('cameraButtonText').textContent = 'Stop Camera';
                document.getElementById('toggleCameraBtn').classList.add('danger');
                document.getElementById('toggleCameraBtn').style.display = 'inline-flex'; // Show camera button
            } else {
                // hide badge
                try { const b = document.getElementById('localBadge'); if (b) { b.style.display = 'none'; } } catch (e) {}
                // Show camera button in "Start" state
                document.getElementById('cameraButtonText').textContent = 'Start Camera';
                document.getElementById('toggleCameraBtn').classList.remove('danger');
                document.getElementById('toggleCameraBtn').style.display = 'inline-flex';
            }

            // Disable mute buttons if no stream is active
            if (!localStream) {
                document.getElementById('muteLocalVideoBtn').disabled = true;
                document.getElementById('muteLocalAudioBtn').disabled = true;
            }

            log('Stopped screen share', 'info');
        } catch (e) {
            console.warn('Error stopping screen share', e);
        }
    }

    // Stream to webrtc-relay if available, otherwise use peer-to-peer (based on selected mode)
    async function startVideoStream(targetAgents) {
        // Defensive checks
        if (!localStream) { log('‚ùå No local stream available to start streaming', 'error'); return; }
        if (!webrtcHelper) { log('‚ùå WebRTC helper not initialized', 'error'); return; }
        if (!channel) { log('‚ùå Signaling channel not available', 'error'); return; }

        const mode = getStreamingMode(); // 'p2p' | 'relay'

        // NEW: Use message filtering based on mode
        let messageFilter = null;

        if (mode === 'relay') {
            // Relay mode: target only webrtc-relay agents
            messageFilter = 'role=webrtc-relay';
            log('üì° Relay mode: Using filter to target webrtc-relay agents', 'info');
        } else {
            // P2P mode: exclude webrtc-relay agents (target regular clients only)
            messageFilter = '!role=webrtc-relay';
            log('üì° P2P mode: Using filter to exclude webrtc-relay agents', 'info');
        }

        // Normalize targetAgents to array (relay mode) or '*' for p2p
        if (!targetAgents) {
            if (mode === 'relay') {
                const relays = window.webrtcRelayAgents || [];
                if (relays.length === 0) {
                    const msg = 'Relay mode selected but no relay agents available';
                    log('‚ùå ' + msg, 'error');
                    showStatus('streamStatus', '‚ùå ' + msg, 'error');
                    return;
                }
                targetAgents = relays;

            } else {
                targetAgents = ['*']; // broadcast
            }
        }

        try {

            log('üì° Sending stream offers with filter: ' + messageFilter + ' to: ' + (Array.isArray(targetAgents) ? targetAgents.join(', ') : targetAgents), 'info');

            const createdStreamIds = [];

            for (const agent of targetAgents) {
                try {
                    // Pass the filter to createStreamOffer
                    const streamId = await webrtcHelper.createStreamOffer(agent, {
                        stream: localStream,
                        filter: messageFilter  // NEW: Pass filter to helper
                    });
                    if (streamId) {
                        createdStreamIds.push(streamId);
                        // ...existing code...
                        if (!currentStreamId) currentStreamId = streamId;
                        log('üì° Offer sent for ' + agent + ' with filter: ' + messageFilter + ' (streamId=' + streamId + ')', 'debug');
                    }
                } catch (e) {
                    console.warn('Failed to create stream offer for agent ' + agent, e);
                }
            }

            if (createdStreamIds.length === 0) {
                throw new Error('No stream offers could be created');
            }

            // If only a single stream created, keep user-facing message concise
            if (createdStreamIds.length === 1) {
                log('‚úÖ Video stream initiated (streamId=' + createdStreamIds[0] + ')', 'success');
                showStatus('streamStatus', `‚úÖ Streaming (streamId=${createdStreamIds[0]})`, 'success');
            } else {
                log('‚úÖ Video stream initiated to ' + createdStreamIds.length + ' targets', 'success');
                showStatus('streamStatus', `‚úÖ Streaming to ${createdStreamIds.length} targets`, 'success');
            }

            document.getElementById('statState').textContent = 'Connecting';

        } catch (error) {
            const msg = (error && error.message) ? error.message : String(error);
            log('‚ùå Failed to start stream: ' + msg, 'error');
            showStatus('streamStatus', '‚ùå Failed: ' + msg, 'error');
        }
    }

    // Stop Video Stream
    function stopVideoStream() {
        if (currentStreamId && webrtcHelper) {
            webrtcHelper.closeStream(currentStreamId);

            log('Stream stopped', 'info');
            showStatus('streamStatus', 'Stream stopped', 'info');

            document.getElementById('statState').textContent = 'Idle';

            if (statsInterval) {
                clearInterval(statsInterval);
                statsInterval = null;
            }

            iceCount = 0;
            document.getElementById('statIce').textContent = '0';
            document.getElementById('statBitrate').textContent = '0 kbps';
            document.getElementById('statFrames').textContent = '0';
        }
    }

    // Monitor WebRTC stats
    function startStatsMonitoring(streamId) {
        if (statsInterval) clearInterval(statsInterval);

        statsInterval = setInterval(async () => {
            // Get WebRTC stats
            const peerConnection = webrtcHelper.peerConnections.get(streamId);
            if (!peerConnection) return;

            try {
                const stats = await peerConnection.getStats();
                stats.forEach(report => {
                    if (report.type === 'outbound-rtp' && report.mediaType === 'video') {
                        if (report.bytesSent) {
                            const bitrate = Math.round(report.bytesSent * 8 / 1000);
                            document.getElementById('statBitrate').textContent = bitrate + ' kbps';
                        }
                        if (report.framesEncoded) {
                            document.getElementById('statFrames').textContent = report.framesEncoded;
                        }
                    }
                });
            } catch (e) {
                console.error('Stats error:', e);
            }
        }, 1000);
    }

    // Mute/Unmute Functions for Local Stream
    function toggleLocalVideoMute() {
        if (!localStream) return;

        const videoTracks = localStream.getVideoTracks();
        if (videoTracks.length === 0) return;

        const videoTrack = videoTracks[0];
        videoTrack.enabled = !videoTrack.enabled;

        const btn = document.getElementById('localVideoMuteText');
        const muteBtn = document.getElementById('muteLocalVideoBtn');

        if (videoTrack.enabled) {
            btn.textContent = 'Disable Video';
            muteBtn.classList.remove('danger');
            log('üìπ Local video enabled', 'success');
        } else {
            btn.textContent = 'Enable Video';
            muteBtn.classList.add('danger');
            log('üìπ Local video disabled', 'info');
        }
    }

    function toggleLocalAudioMute() {
        if (!localStream) return;

        const audioTracks = localStream.getAudioTracks();
        if (audioTracks.length === 0) return;

        const audioTrack = audioTracks[0];
        audioTrack.enabled = !audioTrack.enabled;

        const btn = document.getElementById('localAudioMuteText');
        const muteBtn = document.getElementById('muteLocalAudioBtn');

        if (audioTrack.enabled) {
            btn.textContent = 'Mute Audio';
            muteBtn.classList.remove('danger');
            log('üé§ Local audio unmuted', 'success');
        } else {
            btn.textContent = 'Unmute Audio';
            muteBtn.classList.add('danger');
            log('üîá Local audio muted', 'info');
        }
    }

    // Legacy function - now uses per-stream audio toggle
    function toggleRemoteAudioMute() {
        if (lastReceivedStreamId) {
            toggleRemoteStreamAudio(lastReceivedStreamId);
        }
    }

    // Helper: get selected streaming mode (p2p | relay)
    function getStreamingMode() {
        try {
            const el = document.getElementById('streamingMode');
            const val = (el && el.value) ? el.value : 'p2p';
            return (val === 'relay') ? 'relay' : 'p2p';
        } catch (_) {
            return 'p2p';
        }
    }

    // Initialize on page load
    window.addEventListener('load', () => {
        log('WebRTC Video Sender initialized', 'success');
        log('Ready to connect to messaging channel', 'info');
        log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');

        // Attach click/dblclick handlers for remote video if element exists
        try {
            const container = document.getElementById('remoteVideoBox') || document.getElementById('remoteVideo');
            if (container) {
                container.style.cursor = 'pointer';
                container.addEventListener('dblclick', (e) => {
                    if (e && e.target && (e.target.id === 'remoteFsCloseBtn' || e.target.closest('.remote-fs-close'))) return;
                    toggleRemoteFullscreen();
                });
            }
        } catch (e) { /* ignore */ }

        // Initialize ShareModal component
        if (typeof ShareModal !== 'undefined') {
            ShareModal.init();

            // Wire up share button
            const shareBtn = document.getElementById('shareChannelBtn');
            if (shareBtn) {
                shareBtn.addEventListener('click', async function() {
                    try {
                        const channelName = document.getElementById('channelName').value.trim();
                        const channelPassword = document.getElementById('channelPassword').value.trim();

                        if (!channelName || !channelPassword) {
                            alert('Please fill in channel details before sharing');
                            return;
                        }

                        // Fetch fresh temporary API key for sharing using config-loader
                        console.log('Requesting fresh temporary API key for sharing...');
                        let apiKey;
                        try {
                            // Use multi-use key with 60s TTL for sharing (allows multiple people to use it)
                            const config = await window.fetchAppConfig(60, false);
                            if (!config || !config.apiKey) {
                                throw new Error('No API key in response');
                            }
                            apiKey = config.apiKey;
                            console.log('Fresh temporary API key obtained for sharing (multi-use, 60s TTL)');
                        } catch (err) {
                            console.error('Failed to get temporary API key for sharing:', err);
                            alert('Failed to get API key from server: ' + err.message);
                            return;
                        }

                        ShareModal.show(channelName, channelPassword, apiKey);
                    } catch (e) {
                        console.error('Share error:', e);
                        alert('Failed to open share dialog: ' + e.message);
                    }
                });
            }

            // Process incoming shared links
            ShareModal.processSharedLink(function(auth, agentName) {
                // Fill form fields (agent name will be auto-generated)
                document.getElementById('channelName').value = auth.c;
                document.getElementById('channelPassword').value = auth.p;
                // API key is NOT stored - it will be fetched fresh when connecting

                log('‚úÖ Channel details loaded from shared link!', 'success');
                console.log('[DEBUG] Shared link auth:', auth);
                console.log('[DEBUG] Form values:', {
                    channelName: document.getElementById('channelName').value,
                    password: document.getElementById('channelPassword').value,
                    apiKey: '(will be fetched on connect)'
                });
                showStatus('connectionStatus', '‚úÖ Shared link processed - ready to connect', 'success');

                // Auto-connect after a short delay
                setTimeout(async () => {
                    console.log('[DEBUG] setTimeout callback executing...');
                    const connectBtn = document.getElementById('connectBtn');
                    console.log('[DEBUG] Connect button:', connectBtn, 'disabled:', connectBtn?.disabled);

                    if (connectBtn && !connectBtn.disabled) {
                        log('Auto-connecting from shared link...', 'info');

                        try {
                            console.log('[DEBUG] Calling connectToChannel()...');
                            // Connect to channel to receive remote streams
                            await connectToChannel();
                            console.log('[DEBUG] connectToChannel() completed successfully');
                            log('‚úÖ Connected! Ready to receive streams from other agents', 'success');
                        } catch (err) {
                            console.error('[DEBUG] connectToChannel() error:', err);
                            log('‚ùå Auto-connect failed: ' + err.message, 'error');
                        }
                    } else {
                        console.log('[DEBUG] Connect button check failed - button not found or disabled');
                    }
                }, 1000);
            });
        }
    });

    // Ensure cleanup runs when page closes and exit fullscreen when page is hidden
    // NOTE: Using BOTH 'unload' and 'pagehide' for maximum compatibility:
    // - 'unload': Works on desktop browsers
    // - 'pagehide': More reliable on mobile browsers and handles bfcache
    // - Both only fire when page actually closes (not during warning dialog)
    try {
        window.addEventListener('unload', cleanupBeforeUnload);
        window.addEventListener('pagehide', cleanupBeforeUnload);
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // exit fullscreen when user switches tabs or minimizes to avoid stuck fullscreen
                try { exitFullscreenIfAny(); } catch (e) { /* ignore */ }
            }
        });
    } catch (e) { /* ignore */ }

    // Cleanup on page unload
    function cleanupBeforeUnload() {
        // Ask the channel to send a beacon-style disconnect if available. This is best-effort during unload.
        try {
            if (channel && typeof channel.disconnect === 'function') {
                try {
                    channel.disconnect({ useBeacon: true });
                    log('Requested channel disconnect with beacon', 'info');
                } catch (err) {
                    console.warn('Error while calling channel.disconnect({useBeacon:true}) during unload:', err);
                }
            }
        } catch (e) {
            console.warn('Error attempting beacon disconnect during unload:', e);
        }

         // Stop any active streams and camera
         if (currentStreamId) {
             stopVideoStream();
         }
         if (localStream) {
             // Attempt to stop both camera or screen share
             try { stopScreenShare(); } catch (e) {}
             try { stopCamera(); } catch (e) {}
         }
         // Also stop receiving remote stream if present
         stopReceiving();
     }

    // User-initiated disconnect button handler
    async function disconnectFromChannel() {
        if (!channel) {
            showStatus('connectionStatus', 'Not connected', 'info');
            return;
        }

        // Use the channel's beacon-capable disconnect so the server gets a fast notification even if the page unloads
        try {
            channel.disconnect({ useBeacon: true });
        } catch (e) {
            console.warn('Beacon disconnect failed, falling back to normal disconnect path', e);
        }

        log('Disconnecting from channel...', 'info');
        log('üßπ Cleaning up all streams...', 'info');

        try {
            // === CLEANUP ALL LOCAL STREAMS ===

            // Stop active WebRTC stream session if any
            if (currentStreamId && webrtcHelper) {
                try {
                    log('Closing active WebRTC stream: ' + currentStreamId, 'debug');
                    webrtcHelper.closeStream(currentStreamId);
                } catch (e) {
                    console.warn('Error closing stream:', e);
                }
                currentStreamId = null;
            }

            // Stop camera if active
            if (localStream && !isScreenSharing) {
                try {
                    log('Stopping camera...', 'debug');
                    localStream.getTracks().forEach(track => track.stop());
                    document.getElementById('localVideo').srcObject = null;
                    localStream = null;
                } catch (e) {
                    console.warn('Error stopping camera:', e);
                }
            }

            // Stop screen share if active
            if (isScreenSharing) {
                try {
                    log('Stopping screen share...', 'debug');
                    stopScreenShare();
                } catch (e) {
                    console.warn('Error stopping screen share:', e);
                }
            }

            // Clear saved camera stream
            if (savedCameraStream) {
                try {
                    savedCameraStream.getTracks().forEach(track => track.stop());
                    savedCameraStream = null;
                } catch (e) {
                    console.warn('Error clearing saved camera:', e);
                }
            }

            // === CLEANUP ALL REMOTE STREAMS ===

            if (remoteStreams.size > 0) {
                log('Removing ' + remoteStreams.size + ' remote stream(s)...', 'debug');

                // Create array of streamIds to avoid modification during iteration
                const streamIds = Array.from(remoteStreams.keys());

                // Remove each remote stream
                streamIds.forEach(streamId => {
                    try {
                        const streamData = remoteStreams.get(streamId);
                        if (streamData) {
                            log('Removing remote stream from ' + streamData.sourceAgent, 'debug');

                            // Close WebRTC connection
                            if (webrtcHelper) {
                                try {
                                    webrtcHelper.closeStream(streamId);
                                } catch (e) {
                                    console.warn('Error closing remote stream:', e);
                                }
                            }

                            // Stop tracks
                            if (streamData.videoElement && streamData.videoElement.srcObject) {
                                try {
                                    streamData.videoElement.srcObject.getTracks().forEach(t => t.stop());
                                    streamData.videoElement.srcObject = null;
                                } catch (e) {
                                    console.warn('Error stopping remote tracks:', e);
                                }
                            }

                            // Remove DOM element
                            if (streamData.container && streamData.container.parentElement) {
                                streamData.container.remove();
                            }

                            // Remove from map
                            remoteStreams.delete(streamId);
                        }
                    } catch (e) {
                        console.warn('Error removing remote stream ' + streamId + ':', e);
                    }
                });

                // Update counter and show "no streams" message
                updateRemoteStreamCount();

                log('‚úÖ All remote streams removed', 'success');
            }

            // Clear WebRTC helper state
            if (webrtcHelper) {
                try {
                    // Clear all peer connections
                    if (webrtcHelper.peerConnections) {
                        webrtcHelper.peerConnections.forEach((pc, streamId) => {
                            try {
                                pc.close();
                            } catch (e) {
                                console.warn('Error closing peer connection:', e);
                            }
                        });
                        webrtcHelper.peerConnections.clear();
                    }

                    // Clear stream sessions
                    if (webrtcHelper.streamSessions) {
                        webrtcHelper.streamSessions.clear();
                    }

                    // Clear local streams
                    if (webrtcHelper.localStreams) {
                        webrtcHelper.localStreams.clear();
                    }
                } catch (e) {
                    console.warn('Error clearing WebRTC helper state:', e);
                }
            }

            log('‚úÖ All streams cleaned up', 'success');

            // Channel disconnect was already requested with beacon earlier; if an explicit sync disconnect is desired
            // (for example to wait for server response), call channel.disconnect() here instead of using the beacon flag.
            // We skip the duplicate call to avoid sending the same disconnect twice.
            //
            // if (channel && typeof channel.disconnect === 'function') {
            //     try {
            //         const maybePromise = channel.disconnect();
            //         if (maybePromise && typeof maybePromise.then === 'function') {
            //             await maybePromise;
            //         }
            //     } catch (e) {
            //         console.warn('Error disconnecting channel:', e);
            //     }
            // }

            showStatus('connectionStatus', 'Disconnected', 'info');
            log('Disconnected from channel', 'info');

            // Show connection form and hide connected info
            document.getElementById('connectionForm').style.display = 'block';
            document.getElementById('connectedInfo').style.display = 'none';

            // Don't clear agent name - let user keep it or clear it manually
            // Agent name will only be generated if field is empty on next connect

            // Hide share button
            try {
                const shareBtn = document.getElementById('shareChannelBtn');
                if (shareBtn) shareBtn.style.display = 'none';
            } catch (e) { /* ignore */ }

            // Reset toggle buttons to initial state
            document.getElementById('toggleCameraBtn').disabled = true;
            document.getElementById('toggleCameraBtn').style.display = 'inline-flex';
            document.getElementById('cameraButtonText').textContent = 'Start Camera';
            document.getElementById('toggleCameraBtn').classList.remove('danger');

            document.getElementById('toggleScreenBtn').disabled = true;
            document.getElementById('toggleScreenBtn').style.display = 'inline-flex';
            document.getElementById('screenButtonText').textContent = 'Share Screen';
            document.getElementById('toggleScreenBtn').classList.remove('danger');

            // Disable mute buttons
            document.getElementById('muteLocalVideoBtn').disabled = true;
            document.getElementById('muteLocalAudioBtn').disabled = true;

            // Clear local video preview
            document.getElementById('localVideo').srcObject = null;

            // Hide local badge
            try {
                const b = document.getElementById('localBadge');
                if (b) b.style.display = 'none';
            } catch (e) { /* ignore */ }

            // Reset stats
            document.getElementById('statState').textContent = 'Idle';
            document.getElementById('statIce').textContent = '0';
            document.getElementById('statBitrate').textContent = '0 kbps';
            document.getElementById('statFrames').textContent = '0';
            iceCount = 0;

            // Clear stream status
            showStatus('streamStatus', '', 'info');

        } catch (error) {
            log('‚ùå Disconnection error: ' + error.message, 'error');
        }
    }

    // Share channel helper (used by inline onclick attribute and programmatic handlers)
    async function shareChannel() {
        try {
            const channelName = document.getElementById('channelName')?.value?.trim();
            const channelPassword = document.getElementById('channelPassword')?.value?.trim();

             if (!channelName || !channelPassword) {
                 alert('Please fill in channel details before sharing');
                 return;
             }

            // Fetch fresh temporary API key for sharing using config-loader
            console.log('Requesting fresh temporary API key for sharing...');
            let apiKey;
            try {
                // Use multi-use key with 60s TTL for sharing (allows multiple people to use it)
                const config = await window.fetchAppConfig(60, false);
                if (!config || !config.apiKey) {
                    throw new Error('No API key in response');
                }
                apiKey = config.apiKey;
                console.log('Fresh temporary API key obtained for sharing (multi-use, 60s TTL)');
            } catch (err) {
                console.error('Failed to get temporary API key for sharing:', err);
                alert('Failed to get API key from server: ' + err.message);
                return;
            }

            if (typeof ShareModal === 'undefined' || !ShareModal || typeof ShareModal.show !== 'function') {
                alert('Share modal is not available');
                console.warn('shareChannel: ShareModal not available');
                return;
            }

            // Use ShareModal to display the share UI
            ShareModal.show(channelName, channelPassword, apiKey);
            log('üîó Share modal opened', 'info');
        } catch (err) {
            console.error('shareChannel error', err);
            alert('Failed to open share dialog: ' + (err && err.message ? err.message : err));
        }
    }
</script>
</body>
</html>
